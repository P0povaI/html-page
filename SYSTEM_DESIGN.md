# RPG Web App: System Design

## 1. Overview

This document outlines the system design for a web-based text RPG. The application consists of a JavaScript frontend that interacts with a Python FastAPI backend. The player navigates through rooms, encounters events (fights, chests, shops, etc.), and makes choices that affect their character's state.

A key feature of this application is its use of the **OpenAI API** to dynamically generate a multi-chapter story upon server startup, providing a unique narrative for each playthrough.

## 2. Architecture

The system follows a client-server architecture:

*   **Client (Frontend)**: HTML, CSS, and pure JavaScript running in the user's browser. Responsible for rendering the UI, capturing user input, and managing the player's state between requests.
*   **Server (Backend)**: FastAPI application. Responsible for game logic, processing player actions, and managing game events.

### 2.1. State Management (PoC)

For this Proof of Concept (PoC), the architecture is designed for a **single player**.

*   **Player State**: The backend is **stateless** regarding the player. It does not store player data between API calls. The frontend is responsible for sending the complete player state with every action request.
*   **Story State**: The backend is **stateful** regarding the story. The narrative, generated by AI at startup, is stored in a global object on the server. A counter tracks the current chapter, ensuring the story progresses linearly. This state is shared globally and resets only if the server restarts.

**Core Interaction Model:**
1.  Frontend sends the player's current state and chosen action to a specific backend endpoint.
2.  Backend processes the action, calculates the outcome, and returns the updated player state and a result message.
3.  Frontend updates the UI and its local player state.
4.  To proceed, the frontend requests a new room from the backend, and the loop continues.

## 3. Frontend Design

### 3.1. HTML Structure (Conceptual)

The frontend will be a single-page application, dynamically updating content within these main sections:

* **`index.html`**:
    * **`div#start-screen`**:
        * Input for player name (`input#player-name-input`).
        * (Optional) Player class selection.
        * Button to start the game (`button#start-game-button`).
    * **`div#game-screen`** (initially hidden) this is the main game screen and is full height:
        * **`div#player-stats`**: Displays player's current health, experience, level, and coins (e.g., `span#player-health`, `span#player-xp`). This is a persistent top bar with icons for each stat.
        * **`div#room-area`**:
            * `img#room-image`: Displays an image relevant to the current room/event.
            * `p#room-description`: Textual description of the room or situation.
            * `div#story-content`: For displaying narrative text from story rooms.
            * `div#enemy-info`: Displays initial information about an enemy if present.
        * **`div#action-result`**: Displays text output from actions (e.g., combat logs, item descriptions). This area is cleared and updated after each action.
        * **`div#action-buttons`**: Container for dynamically generated buttons representing player choices.
        * `button#next-room-button`: Used to proceed after an action. This button is always on the bottom of the screen, along with action buttons.
    * **`div#game-over-screen`** (initially hidden): Displays game over message and final stats.
        * `button#restart-game-button`.
    * **`div#game-complete-screen`** (initially hidden): Displays game completion message.
        * `button#play-again-button`.
    * **`div#loading-indicator`** (optional, initially hidden): To show during API calls.

### 3.2. JavaScript (app.js) - Key Components & Logic

* **State Variables**:
    * `currentPlayerState`: Object storing all attributes of the player (health, damage, coins, etc.), matching the `PlayerModel` from the backend. This is the primary payload sent with most requests.
    * `currentRoomData`: Object storing details of the current room (type, description).
    * `currentEnemyData`: Object storing details of the current enemy if a fight is initiated, matching the `EnemyModel` from the backend.

* **Core Functions**:
    * `initGame()`: Handles the "Start Game" button click. Collects player name, calls `/game/start` endpoint.
    * `updatePlayerStatsUI()`: Updates the `#player-stats` div with data from `currentPlayerState`. Checks for player death.
    * `processRoomData(roomData)`:
        * Updates `currentRoomData`.
        * Clears and populates `#room-area`.
        * Dynamically creates action buttons based on `roomData.type`.
    * `handleActionButtonClick(action)`:
        * Prepares the request body, including `currentPlayerState` and `currentEnemyData` if relevant.
        * Makes a `fetch` POST request to the corresponding backend endpoint (e.g., `/actions/fight/attack`).
        * On response:
            * Updates `currentPlayerState`.
            * Calls `updatePlayerStatsUI()`.
            * Displays the `result` text in `#action-result`.
            * Shows the `#next-room-button`.
    * `handleNextRoomButtonClick()`:
        * Makes a `GET` request to `/game/next_room`.
        * On response, calls `processRoomData` with the new room data.
    * `handleGameOver()`: Shows `#game-over-screen`.
    * `handleGameComplete()`: Shows `#game-complete-screen`.

### 3.3. Asset Handling
* Room images will be stored in a `/static` directory served by the backend.
* The frontend will construct the image path (e.g., `/static/{image_name}.png`).

## 4. Backend API Endpoints (FastAPI)

The backend exposes the following endpoints. Models are defined in `models.py`.

### 4.1. Root & Static Files

* **Endpoint**: `/`
    * **Method**: `GET`
    * **Purpose**: Serves the main `index.html` file.
* **Endpoint**: `/static_assets/{path:path}`
    * **Method**: `GET`
    * **Purpose**: Serves static files (CSS, JS, images) from the `static` directory.

### 4.2. Game Management Endpoints

* **Endpoint**: `/game/start`
    * **Method**: `POST`
    * **Purpose**: Initializes a new game.
    * **Request Body**: `PlayerStartModel` (`{ "name": "string" }`)
    * **Response Body**: `GameStartModel` (`{ "player": PlayerModel, "room": RoomModel }`)

* **Endpoint**: `/game/next_room`
    * **Method**: `GET`
    * **Purpose**: Player requests to move to the next room. The backend's `RoomGenerator` determines the next room type randomly.
    * **Response Body**: `RoomModel` (`{ "room_type": "string", "room_description": "string" }`)

### 4.3. Action Endpoints

* **General Response Model**: All action endpoints return an `ActionResult` model:
    ```json
    {
        "player": { ...PlayerModel object... },
        "result": "string" // Textual outcome of the action.
    }
    ```

* **Fight Actions:**
    * **Endpoint**: `/actions/fight/attack`
        * **Purpose**: Player chooses to fight. The backend simulates the **entire fight sequence** in one call.
        * **Request Body**: `FightAttackModel` (`{ "player": PlayerModel, "enemy": EnemyModel }`)
        * **`result`**: Contains the full, turn-by-turn combat log.
    * **Endpoint**: `/actions/fight/run`
        * **Purpose**: Player chooses to run from a fight. There's a chance they take damage while escaping.
        * **Request Body**: `FightRunModel` (`{ "player": PlayerModel, "enemy": EnemyModel }`)
        * **`result`**: Describes the outcome of the escape attempt.
    * **Endpoint**: `/enemy`
        * **Method**: `GET`
        * **Purpose**: Generates a new random enemy when a "Fight" room is entered.
        * **Response Body**: `EnemyModel`

* **Bedroom Actions:**
    * **Endpoint**: `/actions/bedroom/sleep`
        * **Purpose**: Player sleeps to restore full health at a cost.
        * **Request Body**: `BedroomModel` (`{ "player": PlayerModel }`)
    * **Endpoint**: `/bedroom/options`
        * **Method**: `GET`
        * **Purpose**: Returns the cost of sleeping. (`{ "sleep": 5 }`)

* **Casino Actions:**
    * **Endpoint**: `/actions/casino/bet`
        * **Purpose**: Player bets a certain amount of coins.
        * **Request Body**: `CasinoModel` (`{ "bet": int, "player": PlayerModel }`)

* **Marketplace/Shop Actions:**
    * **Endpoint**: `/actions/marketplace/purchase`
        * **Purpose**: Player buys an item from the catalog.
        * **Request Body**: `MarketplaceModel` (`{ "item": "string", "player": PlayerModel }`)
    * **Endpoint**: `/marketplace/catalog`
        * **Method**: `GET`
        * **Purpose**: Returns available items and their prices.

* **Chest Actions:**
    * **Endpoint**: `/actions/chest/open`
        * **Purpose**: Player opens a chest, with a random outcome (loot or trap).
        * **Request Body**: `ChestModel` (`{ "player": PlayerModel }`)

## 5. Data Models (Pydantic)

The backend uses Pydantic models defined in `models.py` for API requests and responses. These models are the source of truth for the data structures.

*   **`PlayerModel`**: Contains all player attributes (health, level, coins, damage, status effects, etc.).
*   **`EnemyModel`**: Contains all enemy attributes (class, type, damage, health, etc.).
*   **`ActionResult`**: The standard response for all action endpoints, containing the updated `player` and a `result` string.
*   **Room/Action Models**: `RoomModel`, `CasinoModel`, `MarketplaceModel`, etc., define the specific request bodies for each endpoint.

## 6. Key User Flows / Interaction Logic

### 6.1. Starting the Game
1.  User enters name, clicks "Start Game".
2.  FE: `POST /game/start` with `{ "name": "PlayerName" }`.
3.  BE: Creates player, determines first room. Returns `{ player: PlayerModel, room: RoomModel }`.
4.  FE: Stores `player`, calls `processRoomData(room)`.

### 6.2. Fight Sequence (Key Example)
1.  FE enters a "Fight" room. It makes a `GET /enemy` request to get enemy data and stores it in `currentEnemyData`.
2.  FE displays enemy info and action buttons ("Attack", "Run").
3.  User clicks "Attack".
4.  FE: `POST /actions/fight/attack` with `{ "player": currentPlayerState, "enemy": currentEnemyData }`.
5.  BE:
    a. Reconstructs `Player` and `Enemy` objects from the request.
    b. Simulates the **entire fight** turn-by-turn internally.
    c. Generates a detailed combat log string.
    d. Returns an `ActionResult` with the final player state and the full combat log as the `result`.
6.  FE:
    a. Updates `currentPlayerState` with the `player` object from the response.
    b. Updates the player stats UI.
    c. Displays the full combat log in the `#action-result` area.
    d. If the player is alive, it shows the "Next Room" button.

### 6.3. Transitioning Between Rooms
1.  After an action is resolved (e.g., fight is over, chest is opened), the user clicks the "Next Room" button.
2.  FE: `GET /game/next_room`.
3.  BE: `RoomGenerator` randomly selects a new room type and description.
4.  BE: Returns a `RoomModel`.
5.  FE: Calls `processRoomData()` with the new room data to render the next scene.

## 7. AI-Powered Story Generation

A unique feature of the backend is its dynamic narrative generation.

*   **Module**: `clients.py`
*   **Trigger**: On server startup.
*   **Process**:
    1.  The `generate_story()` function is called.
    2.  It sends a prompt to the **OpenAI GPT-4o API**, requesting a five-chapter RPG story.
    3.  The AI's response is parsed and loaded into `Chapter` objects.
*   **State**: The generated story is stored in a global `Storyline` object, which tracks the `current_chapter` that has been served. This makes the narrative stateful and shared across the application instance.

## 8. Error Handling (Frontend)

*   Network errors during `fetch` should be caught and displayed to the user.
*   Backend error responses (e.g., 4xx, 5xx status codes) should be handled gracefully.

This design provides a solid foundation for the PoC and outlines a clear path for future multi-tenant development.
